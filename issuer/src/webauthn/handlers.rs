// issuer/src/webauthn/handlers.rs
use axum::{
    extract::{ConnectInfo, Json, State},
    http::{HeaderMap, StatusCode},
    routing::{get, post},
    Router,
};
use base64ct::Encoding;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::net::{IpAddr, SocketAddr};
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, info, warn};
use uuid::Uuid;
use webauthn_rs::prelude::*;

use super::ctx::WebAuthnCtx;
use super::rate_limit::WebAuthnRateLimiter;
use super::store::CredentialStore;

// --- Proof Generation Utilities ---

/// Derive a proof verification key from the RP ID and server secret
///
/// Security: This function derives a key for HMAC-based proof verification.
/// - When WEBAUTHN_PROOF_SECRET is set, uses it as entropy (RECOMMENDED)
/// - Without secret, falls back to deterministic derivation (INSECURE for production)
///
/// NOTE: This derivation MUST match gate.rs for proof verification to work.
fn derive_proof_key(rp_id: &str) -> [u8; 32] {
    // Check for configured secret
    let (secret_bytes, has_secret) = if let Ok(secret) = std::env::var("WEBAUTHN_PROOF_SECRET") {
        // Derive initial key from secret
        let mut key_hasher = blake3::Hasher::new();
        key_hasher.update(b"webauthn:secret:key:v1:");
        key_hasher.update(secret.as_bytes());
        (*key_hasher.finalize().as_bytes(), true)
    } else {
        // Derive a deterministic but unique-per-deployment key from RP ID
        // This is NOT secure but provides some isolation between deployments
        let mut key_hasher = blake3::Hasher::new();
        key_hasher.update(b"webauthn:deterministic:key:v1:");
        key_hasher.update(rp_id.as_bytes());
        key_hasher.update(b":insecure-fallback");
        (*key_hasher.finalize().as_bytes(), false)
    };

    // Now use the derived key for the final proof key derivation
    let mut hasher = blake3::Hasher::new_keyed(&secret_bytes);
    hasher.update(b"webauthn:proof:key:v1:");
    hasher.update(rp_id.as_bytes());
    if !has_secret {
        hasher.update(b":deterministic");
    }

    *hasher.finalize().as_bytes()
}

/// Compute authentication proof for Sybil resistance
/// This proof can only be generated by the server (requires secret key)
fn compute_auth_proof(rp_id: &str, username: &str, timestamp: i64) -> String {
    let proof_key = derive_proof_key(rp_id);
    let mut hasher = blake3::Hasher::new_keyed(&proof_key);
    hasher.update(b"webauthn:auth:");
    hasher.update(username.as_bytes());
    hasher.update(b":");
    hasher.update(&timestamp.to_le_bytes());
    base64ct::Base64UrlUnpadded::encode_string(hasher.finalize().as_bytes())
}

// --- Constants ---

/// Maximum number of active sessions allowed (memory protection)
const MAX_SESSIONS: usize = 10000;

// --- IP Extraction ---

/// Extract client IP from request, handling proxies
fn extract_client_ip(
    connect_info: Option<ConnectInfo<SocketAddr>>,
    headers: &HeaderMap,
    behind_proxy: bool,
) -> Option<IpAddr> {
    if behind_proxy {
        // Try X-Forwarded-For first (may contain comma-separated list)
        if let Some(xff) = headers.get("x-forwarded-for").and_then(|v| v.to_str().ok()) {
            // Take the first (leftmost) IP, which is the original client
            if let Some(first_ip) = xff.split(',').next() {
                if let Ok(ip) = first_ip.trim().parse::<IpAddr>() {
                    return Some(ip);
                }
            }
        }
        // Fallback to X-Real-IP
        if let Some(real_ip) = headers.get("x-real-ip").and_then(|v| v.to_str().ok()) {
            if let Ok(ip) = real_ip.trim().parse::<IpAddr>() {
                return Some(ip);
            }
        }
    }
    // Use direct connection IP
    connect_info.map(|ci| ci.0.ip())
}

// --- State ---

#[derive(Clone)]
pub struct WebAuthnState {
    pub webauthn: Arc<WebAuthnCtx>,
    pub cred_store: CredentialStore,
    pub sessions: Arc<RwLock<HashMap<String, SessionData>>>,
    /// Rate limiter for registration/authentication attempts
    pub rate_limiter: WebAuthnRateLimiter,
    /// Whether running behind a proxy (use X-Forwarded-For)
    pub behind_proxy: bool,
}

impl WebAuthnState {
    /// Create a new WebAuthnState with rate limiting
    pub fn new(
        webauthn: Arc<WebAuthnCtx>,
        cred_store: CredentialStore,
        behind_proxy: bool,
    ) -> Arc<Self> {
        Arc::new(Self {
            webauthn,
            cred_store,
            sessions: Arc::new(RwLock::new(HashMap::new())),
            rate_limiter: WebAuthnRateLimiter::new(),
            behind_proxy,
        })
    }

    /// Cleanup expired sessions and update rate limiter
    pub async fn cleanup_expired_sessions(&self) {
        let mut sessions = self.sessions.write().await;
        let before_count = sessions.len();

        sessions.retain(|_, session| !session.is_expired());

        let removed = before_count - sessions.len();
        if removed > 0 {
            debug!("Cleaned up {} expired WebAuthn sessions", removed);
        }

        // Also cleanup rate limiter state
        self.rate_limiter.cleanup_expired().await;
    }
}

#[derive(Clone, Debug)]
pub enum SessionData {
    Registration {
        state: PasskeyRegistration,
        username: String,
        created_at: i64,
        client_ip: IpAddr,
    },
    Authentication {
        state: PasskeyAuthentication,
        username: String,
        created_at: i64,
        client_ip: IpAddr,
    },
}

impl SessionData {
    pub fn client_ip(&self) -> IpAddr {
        match self {
            SessionData::Registration { client_ip, .. } => *client_ip,
            SessionData::Authentication { client_ip, .. } => *client_ip,
        }
    }

    pub fn is_expired(&self) -> bool {
        let now = chrono::Utc::now().timestamp();
        let created_at = match self {
            SessionData::Registration { created_at, .. } => *created_at,
            SessionData::Authentication { created_at, .. } => *created_at,
        };
        now - created_at > 900 // 15 minutes
    }
}

// --- Router Factory ---

pub fn router(state: Arc<WebAuthnState>) -> Router {
    use super::discoverable::{discoverable_router, admin_router};

    let use_attestation = std::env::var("WEBAUTHN_REQUIRE_ATTESTATION")
        .unwrap_or_else(|_| "false".to_string())
        .eq_ignore_ascii_case("true");

    // Base routes for standard registration/authentication
    let base_router = if use_attestation {
        Router::new()
            .route("/register/start", post(start_registration_extended))
            .route("/register/finish", post(finish_registration_with_attestation))
            .route("/authenticate/start", post(start_authentication))
            .route("/authenticate/finish", post(finish_authentication))
            .route("/info", get(webauthn_info))
            .with_state(state.clone())
    } else {
        Router::new()
            .route("/register/start", post(start_registration))
            .route("/register/finish", post(finish_registration))
            .route("/authenticate/start", post(start_authentication))
            .route("/authenticate/finish", post(finish_authentication))
            .route("/info", get(webauthn_info))
            .with_state(state.clone())
    };

    // Merge discoverable credential routes
    base_router
        .merge(discoverable_router(state.clone()))
        .merge(admin_router(state))
}

// --- Handlers ---

#[derive(Debug, Deserialize)]
pub struct StartRegistrationRequest {
    pub username: String,
    pub display_name: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct StartRegistrationResponse {
    pub options: CreationChallengeResponse,
    pub session_id: String,
}

pub async fn start_registration(
    State(state): State<Arc<WebAuthnState>>,
    connect_info: Option<ConnectInfo<SocketAddr>>,
    headers: HeaderMap,
    Json(req): Json<StartRegistrationRequest>,
) -> Result<Json<StartRegistrationResponse>, (StatusCode, String)> {
    debug!(username = %req.username, "Starting WebAuthn registration");

    // Extract client IP for rate limiting
    let client_ip = extract_client_ip(connect_info, &headers, state.behind_proxy)
        .unwrap_or_else(|| IpAddr::V4(std::net::Ipv4Addr::new(0, 0, 0, 0)));

    // Check rate limit before processing
    if let Err(e) = state.rate_limiter.check_registration_allowed(client_ip).await {
        warn!(ip = %client_ip, error = %e, "Registration rate limited");
        return Err((e.status_code(), e.to_string()));
    }

    // Record the registration attempt
    state.rate_limiter.record_registration_attempt(client_ip).await;

    // Check total session count for memory protection
    {
        let sessions = state.sessions.read().await;
        if sessions.len() >= MAX_SESSIONS {
            warn!("Maximum session limit reached, rejecting registration");
            return Err((
                StatusCode::SERVICE_UNAVAILABLE,
                "Service temporarily unavailable".to_string(),
            ));
        }
    }

    let user_id_hash = {
        use blake3::Hasher;
        let mut hasher = Hasher::new();
        hasher.update(b"webauthn:user:");
        hasher.update(req.username.as_bytes());
        hasher.finalize().to_hex().to_string()
    };

    let existing_creds = state
        .cred_store
        .load_user_credentials(&user_id_hash)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    if !existing_creds.is_empty() {
        warn!(
            username = %req.username,
            cred_count = existing_creds.len(),
            "User already has registered credentials"
        );
        // Generic error message to prevent username enumeration
        // Don't reveal whether the user exists or how many credentials they have
        return Err((
            StatusCode::CONFLICT,
            "Registration not available for this username".to_string(),
        ));
    }

    let exclude_credentials = if existing_creds.is_empty() {
        None
    } else {
        Some(
            existing_creds
                .iter()
                .map(|c| c.cred_id.clone().into())
                .collect(),
        )
    };

    // webauthn-rs 0.5.3 API: start_passkey_registration(uuid, username, display_name, exclude)
    let (options, reg_state) = state
        .webauthn
        .webauthn
        .start_passkey_registration(
            Uuid::new_v4(),
            &req.username,
            &req.display_name
                .clone()
                .unwrap_or_else(|| req.username.clone()),
            exclude_credentials,
        )
        .map_err(|e| {
            warn!(error = %e, "Failed to start registration");
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Registration start failed: {}", e),
            )
        })?;

    let session_id = uuid::Uuid::new_v4().to_string();

    {
        let mut sessions = state.sessions.write().await;
        sessions.insert(
            session_id.clone(),
            SessionData::Registration {
                state: reg_state,
                username: req.username.clone(),
                created_at: chrono::Utc::now().timestamp(),
                client_ip,
            },
        );
        sessions.retain(|_, session| !session.is_expired());
    }

    // Track session creation in rate limiter
    state.rate_limiter.record_session_created(client_ip).await;

    info!(
        username = %req.username,
        session_id = %session_id,
        "Started WebAuthn registration"
    );

    Ok(Json(StartRegistrationResponse {
        options,
        session_id,
    }))
}

#[derive(Debug, Deserialize)]
pub struct FinishRegistrationRequest {
    pub session_id: String,
    pub credential: RegisterPublicKeyCredential,
}

#[derive(Debug, Serialize)]
pub struct FinishRegistrationResponse {
    pub ok: bool,
    pub cred_id: String,
    pub user_id_hash: String,
    pub registered_at: i64,
}

pub async fn finish_registration(
    State(state): State<Arc<WebAuthnState>>,
    Json(req): Json<FinishRegistrationRequest>,
) -> Result<Json<FinishRegistrationResponse>, (StatusCode, String)> {
    debug!(session_id = %req.session_id, "Finishing WebAuthn registration");

    let (reg_state, username, client_ip) = {
        let mut sessions = state.sessions.write().await;
        match sessions.remove(&req.session_id) {
            Some(SessionData::Registration {
                state, username, client_ip, ..
            }) => (state, username, client_ip),
            Some(session) => {
                // Wrong session type - still record session ended
                state.rate_limiter.record_session_ended(session.client_ip()).await;
                return Err((StatusCode::BAD_REQUEST, "Invalid session type".to_string()));
            }
            None => {
                return Err((
                    StatusCode::NOT_FOUND,
                    "Session not found or expired".to_string(),
                ));
            }
        }
    };

    // Record session ended regardless of outcome
    state.rate_limiter.record_session_ended(client_ip).await;

    let passkey = state
        .webauthn
        .webauthn
        .finish_passkey_registration(&req.credential, &reg_state)
        .map_err(|e| {
            warn!(error = %e, session_id = %req.session_id, "Registration failed");
            (
                StatusCode::BAD_REQUEST,
                format!("Registration failed: {}", e),
            )
        })?;

    let user_id_hash = {
        use blake3::Hasher;
        let mut hasher = Hasher::new();
        hasher.update(b"webauthn:user:");
        hasher.update(username.as_bytes());
        hasher.finalize().to_hex().to_string()
    };

    let cred_id = passkey.cred_id().clone();
    state
        .cred_store
        .save(cred_id.clone().into(), passkey, user_id_hash.clone())
        .await
        .map_err(|e| {
            warn!(error = %e, "Failed to save credential");
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Failed to save credential: {}", e),
            )
        })?;

    let cred_id_b64 = base64ct::Base64UrlUnpadded::encode_string(&cred_id);

    info!(
        username = %username,
        cred_id = %cred_id_b64,
        "Completed WebAuthn registration"
    );

    Ok(Json(FinishRegistrationResponse {
        ok: true,
        cred_id: cred_id_b64,
        user_id_hash,
        registered_at: chrono::Utc::now().timestamp(),
    }))
}
// ============================================================================
// Authentication Flow
// ============================================================================

#[derive(Debug, Deserialize)]
pub struct StartAuthenticationRequest {
    pub username: String,
}

#[derive(Debug, Serialize)]
pub struct StartAuthenticationResponse {
    pub options: RequestChallengeResponse,
    pub session_id: String,
}

pub async fn start_authentication(
    State(state): State<Arc<WebAuthnState>>,
    connect_info: Option<ConnectInfo<SocketAddr>>,
    headers: HeaderMap,
    Json(req): Json<StartAuthenticationRequest>,
) -> Result<Json<StartAuthenticationResponse>, (StatusCode, String)> {
    debug!(username = %req.username, "Starting WebAuthn authentication");

    // Add consistent minimum response time to prevent timing-based enumeration
    let start_time = std::time::Instant::now();
    const MIN_RESPONSE_TIME_MS: u64 = 100;

    // Extract client IP for rate limiting
    let client_ip = extract_client_ip(connect_info, &headers, state.behind_proxy)
        .unwrap_or_else(|| IpAddr::V4(std::net::Ipv4Addr::new(0, 0, 0, 0)));

    // Check rate limit before processing
    if let Err(e) = state.rate_limiter.check_auth_allowed(client_ip).await {
        warn!(ip = %client_ip, error = %e, "Authentication rate limited");
        // Ensure consistent timing even for rate limited requests
        let elapsed = start_time.elapsed().as_millis() as u64;
        if elapsed < MIN_RESPONSE_TIME_MS {
            tokio::time::sleep(std::time::Duration::from_millis(MIN_RESPONSE_TIME_MS - elapsed)).await;
        }
        return Err((e.status_code(), e.to_string()));
    }

    // Record the authentication attempt
    state.rate_limiter.record_auth_attempt(client_ip).await;

    // Check total session count for memory protection
    {
        let sessions = state.sessions.read().await;
        if sessions.len() >= MAX_SESSIONS {
            warn!("Maximum session limit reached, rejecting authentication");
            let elapsed = start_time.elapsed().as_millis() as u64;
            if elapsed < MIN_RESPONSE_TIME_MS {
                tokio::time::sleep(std::time::Duration::from_millis(MIN_RESPONSE_TIME_MS - elapsed)).await;
            }
            return Err((
                StatusCode::SERVICE_UNAVAILABLE,
                "Service temporarily unavailable".to_string(),
            ));
        }
    }

    let user_id_hash = {
        use blake3::Hasher;
        let mut hasher = Hasher::new();
        hasher.update(b"webauthn:user:");
        hasher.update(req.username.as_bytes());
        hasher.finalize().to_hex().to_string()
    };

    let stored_creds = state
        .cred_store
        .load_user_credentials(&user_id_hash)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    // Anti-enumeration: Return generic error for non-existent users
    // Use consistent timing to prevent timing-based enumeration attacks
    if stored_creds.is_empty() {
        debug!(username = %req.username, "No credentials found for user (returning generic error)");

        // Ensure consistent response time
        let elapsed = start_time.elapsed().as_millis() as u64;
        if elapsed < MIN_RESPONSE_TIME_MS {
            tokio::time::sleep(std::time::Duration::from_millis(MIN_RESPONSE_TIME_MS - elapsed)).await;
        }

        // Return generic error that doesn't reveal user existence
        // Same error message as other auth failures
        return Err((
            StatusCode::BAD_REQUEST,
            "Authentication failed".to_string(),
        ));
    }

    let passkeys: Vec<Passkey> = stored_creds.into_iter().map(|c| c.credential).collect();

    let (options, auth_state) = state
        .webauthn
        .webauthn
        .start_passkey_authentication(&passkeys)
        .map_err(|e| {
            warn!(error = %e, "Failed to start authentication");
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                "Authentication failed".to_string(),
            )
        })?;

    let session_id = uuid::Uuid::new_v4().to_string();

    {
        let mut sessions = state.sessions.write().await;
        sessions.insert(
            session_id.clone(),
            SessionData::Authentication {
                state: auth_state,
                username: req.username.clone(),
                created_at: chrono::Utc::now().timestamp(),
                client_ip,
            },
        );
        sessions.retain(|_, session| !session.is_expired());
    }

    // Track session creation in rate limiter
    state.rate_limiter.record_session_created(client_ip).await;

    // Ensure consistent response time for successful lookups too
    let elapsed = start_time.elapsed().as_millis() as u64;
    if elapsed < MIN_RESPONSE_TIME_MS {
        tokio::time::sleep(std::time::Duration::from_millis(MIN_RESPONSE_TIME_MS - elapsed)).await;
    }

    info!(
        username = %req.username,
        session_id = %session_id,
        "Started WebAuthn authentication"
    );

    Ok(Json(StartAuthenticationResponse {
        options,
        session_id,
    }))
}

#[derive(Debug, Deserialize)]
pub struct FinishAuthenticationRequest {
    pub session_id: String,
    pub credential: PublicKeyCredential,
}

#[derive(Debug, Serialize)]
pub struct FinishAuthenticationResponse {
    pub ok: bool,
    pub cred_id: String,
    pub username: String,
    pub authenticated_at: i64,
    pub proof: String,
}

pub async fn finish_authentication(
    State(state): State<Arc<WebAuthnState>>,
    Json(req): Json<FinishAuthenticationRequest>,
) -> Result<Json<FinishAuthenticationResponse>, (StatusCode, String)> {
    debug!(session_id = %req.session_id, "Finishing WebAuthn authentication");

    let (auth_state, username, client_ip) = {
        let mut sessions = state.sessions.write().await;
        match sessions.remove(&req.session_id) {
            Some(SessionData::Authentication {
                state, username, client_ip, ..
            }) => (state, username, client_ip),
            Some(session) => {
                // Wrong session type - still record session ended
                state.rate_limiter.record_session_ended(session.client_ip()).await;
                return Err((StatusCode::BAD_REQUEST, "Invalid session type".to_string()));
            }
            None => {
                return Err((
                    StatusCode::NOT_FOUND,
                    "Session not found or expired".to_string(),
                ));
            }
        }
    };

    // Record session ended regardless of outcome
    state.rate_limiter.record_session_ended(client_ip).await;

    let auth_result = state
        .webauthn
        .webauthn
        .finish_passkey_authentication(&req.credential, &auth_state)
        .map_err(|e| {
            warn!(error = %e, session_id = %req.session_id, "Authentication failed");
            (
                StatusCode::UNAUTHORIZED,
                format!("Authentication failed: {}", e),
            )
        })?;

    let cred_id = auth_result.cred_id();
    state.cred_store.update_last_used(cred_id).await.ok();

    let cred_id_b64 = base64ct::Base64UrlUnpadded::encode_string(cred_id);

    // Generate cryptographically secure proof for Sybil resistance
    // This proof is HMAC-based and can only be generated by the server
    let authenticated_at = chrono::Utc::now().timestamp();
    let proof = compute_auth_proof(&state.webauthn.rp_id, &username, authenticated_at);

    info!(
        username = %username,
        cred_id = %cred_id_b64,
        "Completed WebAuthn authentication"
    );

    Ok(Json(FinishAuthenticationResponse {
        ok: true,
        cred_id: cred_id_b64,
        username,
        authenticated_at,
        proof,
    }))
}

// ============================================================================
// Info Endpoint
// ============================================================================

#[derive(Debug, Serialize)]
pub struct WebAuthnInfo {
    pub rp_id: String,
    pub rp_name: String,
    pub origin: String,
}

pub async fn webauthn_info(State(state): State<Arc<WebAuthnState>>) -> Json<WebAuthnInfo> {
    Json(WebAuthnInfo {
        rp_id: state.webauthn.rp_id.clone(),
        rp_name: state.webauthn.rp_name.clone(),
        origin: state.webauthn.rp_origin.clone(),
    })
}

// ============================================================================
// Extended Registration (with attestation policy enforcement)
// ============================================================================

/// Extended start registration that checks user credential limits
pub async fn start_registration_extended(
    State(state): State<Arc<WebAuthnState>>,
    connect_info: Option<ConnectInfo<SocketAddr>>,
    headers: HeaderMap,
    Json(req): Json<StartRegistrationRequest>,
) -> Result<Json<StartRegistrationResponse>, (StatusCode, String)> {
    use super::attestation::AttestationConfig;

    debug!(username = %req.username, "Starting extended WebAuthn registration");

    let client_ip = extract_client_ip(connect_info, &headers, state.behind_proxy)
        .unwrap_or_else(|| IpAddr::V4(std::net::Ipv4Addr::new(0, 0, 0, 0)));

    // Check rate limit
    if let Err(e) = state.rate_limiter.check_registration_allowed(client_ip).await {
        warn!(ip = %client_ip, error = %e, "Registration rate limited");
        return Err((e.status_code(), e.to_string()));
    }

    state.rate_limiter.record_registration_attempt(client_ip).await;

    // Check max credentials per user
    let config = AttestationConfig::global();
    let user_id_hash = {
        use blake3::Hasher;
        let mut hasher = Hasher::new();
        hasher.update(b"webauthn:user:");
        hasher.update(req.username.as_bytes());
        hasher.finalize().to_hex().to_string()
    };

    let existing_creds = state
        .cred_store
        .load_user_credentials(&user_id_hash)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;

    if existing_creds.len() >= config.max_credentials_per_user {
        warn!(
            username = %req.username,
            count = existing_creds.len(),
            max = config.max_credentials_per_user,
            "User has reached maximum credential limit"
        );
        return Err((
            StatusCode::CONFLICT,
            format!(
                "Maximum of {} credentials per user reached",
                config.max_credentials_per_user
            ),
        ));
    }

    // Continue with normal registration flow
    let exclude_credentials = if existing_creds.is_empty() {
        None
    } else {
        Some(
            existing_creds
                .iter()
                .map(|c| c.cred_id.clone().into())
                .collect(),
        )
    };

    let (options, reg_state) = state
        .webauthn
        .webauthn
        .start_passkey_registration(
            Uuid::new_v4(),
            &req.username,
            &req.display_name
                .clone()
                .unwrap_or_else(|| req.username.clone()),
            exclude_credentials,
        )
        .map_err(|e| {
            warn!(error = %e, "Failed to start registration");
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Registration start failed: {}", e),
            )
        })?;

    let session_id = uuid::Uuid::new_v4().to_string();

    {
        let mut sessions = state.sessions.write().await;
        sessions.insert(
            session_id.clone(),
            SessionData::Registration {
                state: reg_state,
                username: req.username.clone(),
                created_at: chrono::Utc::now().timestamp(),
                client_ip,
            },
        );
        sessions.retain(|_, session| !session.is_expired());
    }

    state.rate_limiter.record_session_created(client_ip).await;

    info!(
        username = %req.username,
        session_id = %session_id,
        "Started extended WebAuthn registration"
    );

    Ok(Json(StartRegistrationResponse {
        options,
        session_id,
    }))
}

/// Extended finish registration with full attestation policy enforcement
pub async fn finish_registration_with_attestation(
    State(state): State<Arc<WebAuthnState>>,
    Json(req): Json<FinishRegistrationRequest>,
) -> Result<Json<FinishRegistrationResponse>, (StatusCode, String)> {
    use super::attestation::{enforce_policy, parse_attestation_info, AttestationConfig, RegistrationAuditMetadata, store_audit_metadata};
    use super::store::{CredentialCreateOptions, DeviceType};

    debug!(session_id = %req.session_id, "Finishing WebAuthn registration with full attestation check");

    let (reg_state, username, client_ip) = {
        let mut sessions = state.sessions.write().await;
        match sessions.remove(&req.session_id) {
            Some(SessionData::Registration {
                state, username, client_ip, ..
            }) => (state, username, client_ip),
            Some(session) => {
                state.rate_limiter.record_session_ended(session.client_ip()).await;
                return Err((StatusCode::BAD_REQUEST, "Invalid session type".to_string()));
            }
            None => {
                return Err((
                    StatusCode::NOT_FOUND,
                    "Session not found or expired".to_string(),
                ));
            }
        }
    };

    state.rate_limiter.record_session_ended(client_ip).await;

    // Parse attestation info BEFORE finishing registration
    let attestation_info = parse_attestation_info(&req.credential);

    // Enforce attestation policy
    let config = AttestationConfig::global();
    let policy_result = enforce_policy(&req.credential, config)?;

    info!(
        allowed = policy_result.allowed,
        reason = %policy_result.reason,
        format = %attestation_info.format,
        aaguid = ?attestation_info.aaguid,
        "Attestation policy check completed"
    );

    // Complete registration
    let passkey = state
        .webauthn
        .webauthn
        .finish_passkey_registration(&req.credential, &reg_state)
        .map_err(|e| {
            warn!(error = %e, session_id = %req.session_id, "Registration failed");
            (
                StatusCode::BAD_REQUEST,
                format!("Registration failed: {}", e),
            )
        })?;

    let user_id_hash = {
        use blake3::Hasher;
        let mut hasher = Hasher::new();
        hasher.update(b"webauthn:user:");
        hasher.update(username.as_bytes());
        hasher.finalize().to_hex().to_string()
    };

    let cred_id = passkey.cred_id().clone();

    // Determine device type from attestation
    let device_type = match attestation_info.format.as_str() {
        "apple" | "tpm" | "android-key" => DeviceType::Platform,
        "packed" | "fido-u2f" => DeviceType::CrossPlatform,
        _ => DeviceType::Unknown,
    };

    // Save credential with extended metadata
    let create_options = CredentialCreateOptions {
        device_type,
        backup_eligible: attestation_info.flags.backup_eligible,
        backup_state: attestation_info.flags.backup_state,
        transports: Vec::new(),
        attestation_format: Some(attestation_info.format.clone()),
        aaguid: attestation_info.aaguid.clone(),
        is_discoverable: false,
        user_handle: None,
        friendly_name: None,
    };

    state
        .cred_store
        .save_with_options(
            cred_id.clone().into(),
            passkey,
            user_id_hash.clone(),
            username.clone(),
            create_options,
        )
        .await
        .map_err(|e| {
            warn!(error = %e, "Failed to save credential");
            (
                StatusCode::INTERNAL_SERVER_ERROR,
                format!("Failed to save credential: {}", e),
            )
        })?;

    // Store audit metadata if Redis is configured
    if let Ok(redis_url) = std::env::var("WEBAUTHN_REDIS_URL") {
        let audit_metadata = RegistrationAuditMetadata {
            username: username.clone(),
            registered_at: chrono::Utc::now().timestamp(),
            policy: format!("{:?}", config.policy),
            attestation_format: attestation_info.format.clone(),
            aaguid: attestation_info.aaguid.clone(),
            self_attestation: attestation_info.self_attestation,
            backup_eligible: attestation_info.flags.backup_eligible,
            backup_state: attestation_info.flags.backup_state,
            client_ip: Some(client_ip.to_string()),
            user_agent: None,
        };
        store_audit_metadata(&redis_url, &cred_id, &audit_metadata).await;
    }

    let cred_id_b64 = base64ct::Base64UrlUnpadded::encode_string(&cred_id);

    info!(
        username = %username,
        cred_id = %cred_id_b64,
        device_type = %device_type,
        backup_eligible = attestation_info.flags.backup_eligible,
        "Completed WebAuthn registration with attestation enforcement"
    );

    Ok(Json(FinishRegistrationResponse {
        ok: true,
        cred_id: cred_id_b64,
        user_id_hash,
        registered_at: chrono::Utc::now().timestamp(),
    }))
}